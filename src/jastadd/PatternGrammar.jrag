import java.util.HashSet;
import org.jgrapht.*;
import org.jgrapht.graph.*;
import org.jgrapht.traverse.*;
import org.jgrapht.io.*;
import org.jgrapht.alg.connectivity.*;
import java.io.*;
import java.util.AbstractMap.SimpleEntry;
import java.util.Collections;
import org.jastadd.jastaddparser.MetaRuleSolver;

aspect PatternGrammar {


	inh Grammar Clause.getGrammar();
	eq Grammar.getClause().getGrammar() = this;
	inh Grammar Element.getGrammar();
	inh Grammar Definition.getGrammar();


	inh Definition Element.parentDefinition();
	eq Definition.getElement().parentDefinition() = this;
	inh Rule Definition.parentRule();
	eq Rule.getDefinition().parentRule() = this;

	syn String Element.type() {
		for (Rule r : getGrammar().rule(getIdUse().getID()))
			return r.type();
		return null;
	}

	private java.util.List<Rule> Grammar.buildMetaVarRule(String name, String type) {
		java.util.List<Rule> clauseList = new java.util.ArrayList<Rule>();
		{
			Rule metaOrConcreteNoGapRule = new Rule();
			metaOrConcreteNoGapRule.setIdUse(new IdUse(type));
			metaOrConcreteNoGapRule.setIdDecl(new IdDecl("META_OR_CONCRETE_NO_GAP_" + name));

			Definition originalDef = new Definition();
			originalDef.addElement(new Element(new IdUse(name), new Opt()));
			metaOrConcreteNoGapRule.addDefinition(originalDef);

			Definition metaVarDef = new Definition();
			Element el = new Element(new IdUse("METAVARID"), new Opt(new IdUse("id")));
			metaVarDef.addElement(el);
			Precedence prec = new Precedence(new IdUse("PREC_1_" + name));
			metaVarDef.addPrecedence(prec);
			String code = String.format("return new MetaVar%s().setVar(new MetaVariable(id));", type);
			metaVarDef.setCODE(code);
			metaOrConcreteNoGapRule.addDefinition(metaVarDef);

			clauseList.add(metaOrConcreteNoGapRule);
		}

		{
			Rule metaOrConcreteRule = new Rule();
			metaOrConcreteRule.setIdUse(new IdUse(type));
			metaOrConcreteRule.setIdDecl(new IdDecl("META_OR_CONCRETE_" + name));

			Definition metaOrConcreteNoGap = new Definition();
			metaOrConcreteNoGap.addElement(new Element(new IdUse("META_OR_CONCRETE_NO_GAP_" + name), new Opt()));
			metaOrConcreteRule.addDefinition(metaOrConcreteNoGap);

			Definition gapDef = new Definition();
			Element el = new Element(new IdUse("GAP"), new Opt());
			gapDef.addElement(el);
			Precedence prec = new Precedence(new IdUse("PREC_2_" + name));
			gapDef.addPrecedence(prec);
			String code = String.format("return new Gap%s();", type);
			gapDef.setCODE(code);
			metaOrConcreteRule.addDefinition(gapDef);

			clauseList.add(metaOrConcreteRule);
		}
		return clauseList;
	}

	private Assoc Grammar.buildPrecedenceStmt(String prec, String name) {
		return new Assoc(prec, new List(new IdUse(name)));
	}

	public void Grammar.addPatternGrammarClauses() {
		ArrayList<Element> metaRuleElems = new ArrayList<Element>();
		Set<Element> metaRuleListMember = new HashSet<Element>();

		for (Rule r : rules()) {
			for (Definition d : r.getDefinitions()) {
				for (Element e : d.getElements()) {
					// no metavariables for non-terminals
					if (!e.isNonTerminal())
						continue;
					// no metavariables for list or strings
					if (e.type().equals("List") || e.type().equals("String"))
						continue;

					// record element, to replace it with a metavariable element
					metaRuleElems.add(e);

					// if the rule is a list, the we want to also allow gaps for
					// the elements
					if (r.type().equals("List"))
						metaRuleListMember.add(e);
				}
			}
		}

		TreeMap<String, String> metaRules = new TreeMap<String, String>();
		for (Element e : metaRuleElems) {
			metaRules.put(e.getIdUse().getID(), e.type());
			if (!e.hasName()) {
				// explicitly name the element to the name of
				// the original, if it was unnamed; the code might use this name
				e.setName(new IdUse(e.getIdUse().getID()));
			}
			e.setIdUse(new IdUse("META_OR_CONCRETE_" + (metaRuleListMember.contains(e) ? "" : "NO_GAP_") + e.getIdUse().getID()));
		}

		for (Map.Entry<String, String> ruleName : metaRules.entrySet()) {
			String name = ruleName.getKey();
			String type = ruleName.getValue();

			java.util.List<Rule> mvrs = buildMetaVarRule(name, type);
			for (Rule mvr : mvrs) {
				addClause(mvr);
			}
		}

		for (Rule r : rules()) {
			for (Definition d : r.getDefinitions()) {
				for (Element e : d.getElements()) {
					e.flushAttrCache();
				}
				d.flushAttrCache();
			}
			r.flushAttrCache();
		}
		flushAttrCache();
		flushCollectionCache();
	}

	syn boolean Element.isTrivialChain() {
		if (isOptional())
			return false;
		if (isList())
			return false;
		Definition d = parentDefinition();
		if (d.getCODE() != null && d.getCODE().length() != 0)
			return false;
		if (d.getNumElement() != 1)
			return false;
		return true;
	}

	syn boolean Definition.isTrivialChain() {
		return getNumElement() == 1 && getElement(0).isTrivialChain();
	}

	syn boolean Definition.isMetaVar() {
		if (getNumElement() != 1)
			return false;
		return getElement(0).getIdUse().getID().equals("METAVARID");
	}

	syn Set<Rule> Rule.chainRules() {
		HashSet<Rule> chainedRules = new HashSet<Rule>();
		for (Definition d : getDefinitions()) {
			if (d.isTrivialChain()) {
				String ruleId = d.getElement(0).getIdUse().getID();
				Rule r = getGrammar().ruleByName().get(ruleId);
				chainedRules.add(r);
				chainedRules.addAll(r.chainRules());
			}
		}
		return chainedRules;
	}

	public class HashSetMap<K, V> extends HashMap<K, Set<V>> {
		public void append(Map.Entry<K, V> e) {
			Set<V> s = get(e.getKey());
			if (s == null) {
				s = new HashSet<V>();
				put(e.getKey(), s);
			}
			s.add(e.getValue());
		}
	}

	coll HashSetMap<Rule, Element> Grammar.ruleUses() [new HashSetMap<Rule, Element>()] with append;
	Element contributes
		new SimpleEntry<Rule, Element>(getGrammar().ruleByName().get(getIdUse().getID()), this)
		when isNonTerminal()
		to Grammar.ruleUses();

	syn boolean Rule.hasNonTrivialUses() {
		if (!getGrammar().ruleUses().containsKey(this))
			return false;

		for (Element e : getGrammar().ruleUses().get(this)) {
			if (!e.isTrivialChain())
				return true;
		}
		return false;
	}

	syn boolean Rule.hasMetaVar() {
		for (Definition d : getDefinitions()) {
			if (d.isMetaVar())
				return true;
			if (d.isTrivialChain()) {
				String ruleId = d.getElement(0).getIdUse().getID();
				Rule r = getGrammar().ruleByName().get(ruleId);
				if (r.hasMetaVar())
					return true;
			}
		}
		return false;
	}
}
