import java.util.HashSet;
import org.jgrapht.*;
import org.jgrapht.graph.*;
import org.jgrapht.traverse.*;

aspect MetaGrammar {
	//syn Set<Rule> Rule.mayAmbiguate() circular [new HashSet<Rule>()];

	syn boolean Grammar.rulesMayBeEmpty(String name) circular [true] {
		for (Rule l : rule(name)) {
			if (l.maybeEmpty()) {
				return true;
			}
		}
		return false;
	}

	inh Grammar Clause.getGrammar();
	eq Grammar.getClause().getGrammar() = this;
	inh Grammar Element.getGrammar();
	inh Grammar Definition.getGrammar();

	syn boolean Definition.maybeEmpty() circular [true] {
		// trivially empty
		if (getNumElement() == 0)
			return true;
		// may be empty if there are no terminals and
		// all the non-terminals may be empty
		for (Element e : getElements()) {
			if (!e.isNonTerminal()) {
				return false;
			} else if (e instanceof OptionalElement
					   || e instanceof ListElement) {
				// skip, Optional and List may be empty
			} else {
				Grammar g = getGrammar();
				if (!g.rulesMayBeEmpty(e.getIdUse().getID()))
					return false;
			}
		}

		return true;
	}

	syn boolean Rule.maybeEmpty() circular [true] {
		for (Definition d : getDefinitions()) {
			if (d.maybeEmpty())
				return true;
		}
		return false;
	}

	syn boolean Element.mayAmbiguate(Rule other) circular [false] {
		for (Rule l : getGrammar().rule(getIdUse().getID())) {
			if (l.mayAmbiguate(other))
				return true;
		}
		return false;
	}

	syn boolean Element.mayAmbiguate(Element other) circular [false] {
		for (Rule r : getGrammar().rule(getIdUse().getID()))
			for (Rule l : getGrammar().rule(other.getIdUse().getID()))
				if (r.mayAmbiguate(l))
					return true;
		return false;
	}

	syn boolean Definition.mayAmbiguate(Rule other) circular [false] {
		String otherName = other.getIdDecl().getID();
		boolean present = false;
		Grammar g = getGrammar();

		for (Element e : getElements()) {
			if (!e.isNonTerminal())
				return false;
			if (e.getIdUse().getID().equals(otherName))
				present = true;
		}

		if (!present)
			return false;

		for (Element e : getElements()) {
			if (!e.mayAmbiguate(other))
				continue;
			// e can clash with other; if the other elements can be empty
			// then this rule can clash with the other rule
			for (Element f : getElements()) {
				if (e.mayAmbiguate(f))
					continue;
				if (!g.rulesMayBeEmpty(f.getIdUse().getID()))
					return false;
			}
		}

		return true;
	}

	syn boolean Rule.mayAmbiguate(Rule other) circular [false] {
		for (Definition d : getDefinitions()) {
			if (d.mayAmbiguate(other))
				return true;
		}

		return false;
	}

	syn boolean Rule.isAmbigous() {
		for (Rule l : getGrammar().rules())
			if (mayAmbiguate(l))
				return true;
		return false;
	}

	syn boolean Rule.isAmbiguated() {
		for (Rule l : getGrammar().rules())
			if (l.mayAmbiguate(this))
				return true;
		return false;
	}

	syn List<Clause> Grammar.getMetaVariableClausesList() {
		List<Clause> clauseList = new List<Clause>();
		for (Rule r : rules()) {
			if (!r.isAmbigous())
				clauseList.add(r);
		}
		return clauseList;
	}

	public Iterator<String> Grammar.getRulePriority() {
		Graph<String, DefaultEdge> directedGraph =
            new DefaultDirectedGraph<String, DefaultEdge>(DefaultEdge.class);
		for (Rule r : rules()) {
			directedGraph.addVertex(r.getIdDecl().getID());
		}
		for (Rule r : rules()) {
			for (Rule l : rules()) {
				if (r.mayAmbiguate(l)) {
					directedGraph.addEdge(r.getIdDecl().getID(),
										  l.getIdDecl().getID());
				}
			}
		}

		java.util.Set<String> unambigousRules = new TreeSet<String>();

		for (Rule r : rules()) {
			if (!r.isAmbigous())
				unambigousRules.add(r.getIdDecl().getID());
		}

		// Iterator<String> it = unambigousRules.iterator();
		// if (it.hasNext()) {
		// 	String current = it.next();
		// 	while (it.hasNext()) {
		// 		String next = it.next();
		// 		directedGraph.addVertex(current);
		// 		directedGraph.addVertex(next);
		// 		directedGraph.addEdge(current, next);
		// 	}
		// }

		return new TopologicalOrderIterator<String, DefaultEdge>(directedGraph);
	}

	private Rule Grammar.buildMetaVarRule(Rule r) {
		Rule metaVarRule = new Rule();
		metaVarRule.setIdUse(r.getIdUse().treeCopyNoTransform());
		metaVarRule.setIdDecl(new IdDecl("META_OR_CONCRETE_" + r.getIdDecl().getID()));

		{
			Definition originalDef = new Definition();
			originalDef.addElement(new Element(new IdUse(r.getIdDecl().getID()), new Opt()));
			metaVarRule.addDefinition(originalDef);
		}

		{
			Definition metaVarDef = new Definition();
			Element el = new Element(new IdUse("METAVARID"), new Opt(new IdUse("id")));
			metaVarDef.addElement(el);
			Precedence prec = new Precedence(new IdUse("PREC_1_" + r.getIdDecl().getID()));
			metaVarDef.addPrecedence(prec);
			String code = String.format("return new MetaVar%s().setVar(new MetaVariable(id));",
										r.getIdUse().getID());
			metaVarDef.setCODE(code);
			metaVarRule.addDefinition(metaVarDef);
		}

		{
			Definition indexVarDef = new Definition();
			indexVarDef.addElement(new Element(new IdUse("METAVARID"), new Opt(new IdUse("idx"))));
			indexVarDef.addElement(new Element(new IdUse("COLON"), new Opt()));
			indexVarDef.addElement(new Element(new IdUse("METAVARID"), new Opt(new IdUse("id"))));
			Precedence prec = new Precedence(new IdUse("PREC_2_" + r.getIdDecl().getID()));
			indexVarDef.addPrecedence(prec);
			String code = String.format("return new IndexMetaVar%s().setVar(new MetaVariable(idx)).setElement(new MetaVar%s().setVar(new MetaVariable(id)));", r.getIdUse().getID(), r.getIdUse().getID());
			indexVarDef.setCODE(code);
			metaVarRule.addDefinition(indexVarDef);
		}

		{
			Definition indexVarDef = new Definition();
			indexVarDef.addElement(new Element(new IdUse("METAVARID"), new Opt(new IdUse("idx"))));
			indexVarDef.addElement(new Element(new IdUse("COLON"), new Opt()));
			indexVarDef.addElement(new Element(new IdUse(r.getIdDecl().getID()), new Opt(new IdUse("id"))));
			Precedence prec = new Precedence(new IdUse("PREC_3_" + r.getIdDecl().getID()));
			indexVarDef.addPrecedence(prec);
			String code = String.format(" return new IndexMetaVar%s().setVar(new MetaVariable(idx)).setElement(id);",
										 r.getIdUse().getID());
			indexVarDef.setCODE(code);
			metaVarRule.addDefinition(indexVarDef);
		}

		{
			Definition gapDef = new Definition();
			Element el = new Element(new IdUse("GAP"), new Opt());
			gapDef.addElement(el);
			Precedence prec = new Precedence(new IdUse("PREC_4_" + r.getIdDecl().getID()));
			gapDef.addPrecedence(prec);
			String code = String.format("return new Gap%s();",
										r.getIdUse().getID());
			gapDef.setCODE(code);
			metaVarRule.addDefinition(gapDef);
		}


		return metaVarRule;
	}

	private Assoc Grammar.buildPrecedenceStmt(String name) {
		return new Assoc("nonassoc",
						 new List(new IdUse(name)));
	}

	public void Grammar.replaceHeader(String s) {
		for (Clause c : getClauses()) {
			if (c instanceof Header) {
				Header h = (Header)c;
				h.setCODE(s);
			}
		}
		flushAttrCache();
	}

	public void Grammar.addPatternGrammarClauses() {
		Set<String> modifiedProductions = new HashSet<String>();
		java.util.List<Rule> metaVarRules = new java.util.ArrayList<Rule>();
		Set<String> goals = new TreeSet<String>();

		for (Rule r : rules()) {
			if (r.type().equals("ASTNode"))
				continue;
			if (r.type().equals("List"))
				continue;
			if (modifiedProductions.contains(r.getIdDecl().getID()))
				continue;

			goals.add(r.getIdDecl().getID());
			if (!r.isAmbigous() && r.isAmbiguated()) {
				//goals.add(r.getIdDecl().getID());
				continue;
			}

			modifiedProductions.add(r.getIdDecl().getID());
			metaVarRules.add(buildMetaVarRule(r));
		}

		for (Rule r : rules()) {
			for (Definition d : r.getDefinitions()) {
				for (Element e : d.getElements()) {
					if (modifiedProductions.contains(e.getIdUse().getID())) {
						e.setIdUse(new IdUse("META_OR_CONCRETE_" + e.getIdUse().getID()));
					}
				}
			}
		}

		getClauses().addAll(metaVarRules);

		Iterator<String> rulePri = getRulePriority();
		while (rulePri.hasNext()) {
			String rule = rulePri.next();
			if (!modifiedProductions.contains(rule))
				continue;
			addClause(buildPrecedenceStmt("PREC_1_" + rule));
			addClause(buildPrecedenceStmt("PREC_2_" + rule));
			addClause(buildPrecedenceStmt("PREC_3_" + rule));
			addClause(buildPrecedenceStmt("PREC_4_" + rule));
		}

		for (String goalName : goals) {
			addClause(new Goal(goalName));
		}


		for (Rule r : rules()) {
			for (Definition d : r.getDefinitions()) {
				for (Element e : d.getElements()) {
					e.flushAttrCache();
				}
				d.flushAttrCache();
			}
			r.flushAttrCache();
		}
		flushAttrCache();
	}

}
