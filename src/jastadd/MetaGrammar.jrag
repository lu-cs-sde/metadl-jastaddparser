import java.util.HashSet;
import org.jgrapht.*;
import org.jgrapht.graph.*;
import org.jgrapht.traverse.*;
import org.jgrapht.io.*;
import org.jgrapht.alg.connectivity.*;
import java.io.*;


aspect MetaGrammar {
	syn boolean Grammar.rulesMayBeEmpty(String name) circular [true] {
		for (Rule l : rule(name)) {
			if (l.maybeEmpty()) {
				return true;
			}
		}
		return false;
	}

	inh Grammar Clause.getGrammar();
	eq Grammar.getClause().getGrammar() = this;
	inh Grammar Element.getGrammar();
	inh Grammar Definition.getGrammar();

	syn boolean Definition.maybeEmpty() circular [true] {
		// trivially empty
		if (getNumElement() == 0)
			return true;
		// may be empty if there are no terminals and
		// all the non-terminals may be empty
		for (Element e : getElements()) {
			if (!e.isNonTerminal()) {
				return false;
			} else if (e instanceof OptionalElement
					   || e instanceof ListElement) {
				// skip, Optional and List may be empty
			} else {
				Grammar g = getGrammar();
				if (!g.rulesMayBeEmpty(e.getIdUse().getID()))
					return false;
			}
		}

		return true;
	}

	syn boolean Rule.maybeEmpty() circular [true] {
		for (Definition d : getDefinitions()) {
			if (d.maybeEmpty())
				return true;
		}
		return false;
	}

	syn boolean Element.includes(Rule other) circular [false] {
		for (Rule l : getGrammar().rule(getIdUse().getID())) {
			if (l.includes(other))
				return true;
		}
		return false;
	}

	inh Definition Element.parentDefinition();
	eq Definition.getElement().parentDefinition() = this;
	inh Rule Definition.parentRule();
	eq Rule.getDefinition().parentRule() = this;

	syn boolean Element.isAlias() {
		return parentDefinition().isAlias();
	}

	syn boolean Definition.isAlias() {
		if (getNumElement() != 1)
			return false;
		if (getElement(0) instanceof ListElement ||
			getElement(0) instanceof ListPlusElement)
			return false;
		return true;
	}

	syn boolean Element.includes(Element other) circular [false] {
		for (Rule r : getGrammar().rule(getIdUse().getID()))
			for (Rule l : getGrammar().rule(other.getIdUse().getID()))
				if (r.includes(l))
					return true;
		return false;
	}

	syn boolean Definition.includes(Rule other) circular [false] {
		String otherName = other.getIdDecl().getID();
		boolean present = false;
		Grammar g = getGrammar();

		for (Element e : getElements()) {
			if (!e.isNonTerminal())
				return false;
			if (e.getIdUse().getID().equals(otherName))
				present = true;
		}

		if (!present)
			return false;

		for (Element e : getElements()) {
			if (!e.includes(other))
				continue;
			// e can clash with other; if the other elements can be empty
			// then this rule can clash with the other rule
			for (Element f : getElements()) {
				if (e.includes(f))
					continue;
				if (!g.rulesMayBeEmpty(f.getIdUse().getID()))
					return false;
			}
		}

		return true;
	}



	syn boolean Rule.includes(Rule other) circular [false] {
		if (type().equals("List"))
			return false;

		for (Definition d : getDefinitions()) {
			if (d.includes(other))
				return true;
		}

		// transitive closure
		for (Rule t : getGrammar().rules())
			if (includes(t) && t.includes(other))
				return true;

		return false;
	}

	syn Set<Rule> Rule.allIncludes() {
		Set<Rule> inc = new HashSet<Rule>();
		for (Rule r : getGrammar().rules())
			if (includes(r))
				inc.add(r);
		return inc;
	}

	syn boolean Rule.includes(String other) {
		for (Rule r : getGrammar().rule(other)) {
			if (includes(r))
				return true;
		}
		return false;
	}

	syn boolean Rule.hasMetaOrConcreteDecl() circular [false] {
		if (type().equals("List") || type().equals("String"))
			return false;

		if (allIncludes().isEmpty()) {
			for (Element e : uses())
				if (!e.isAlias())
					return true;
		} else {
			for (Rule r : allIncludes()) {
				if (r.hasMetaOrConcreteDecl())
					return false;
			}
		}
		return true;
	}

	syn boolean Element.hasMetaOrConcreteDecl() {
		if (!isNonTerminal())
			return false;

		if (this instanceof ListElement ||
			this instanceof ListPlusElement)
			return false;

		boolean ruleHasDecl = false;
		for (Rule r : getGrammar().rule(getIdUse().getID()))
			if (r.hasMetaOrConcreteDecl())
				ruleHasDecl = true;

		if (!ruleHasDecl)
			return false;


		if (!isAlias()) {
			return true;
		} else {
			for (Definition d : parentDefinition().parentRule().getDefinitions()) {
				if (d.isAlias()) {
					if (d == parentDefinition())
						return true;
					return false;
				}
			}
		}

		return false;
	}

	public class GrammarEdgeType {
		private String type;
		private GrammarEdgeType(String type) { this.type = type; }
		public static GrammarEdgeType use() {
			return new GrammarEdgeType("USE");
		}
		public static GrammarEdgeType include() {
			return new GrammarEdgeType("INCLUDE");
		}
		public String toString() { return type; }
		public boolean isUse() { return type.equals("USE"); }
    }

	public Graph<String, GrammarEdgeType> Grammar.buildGrammarGraph() {
		Graph<String, GrammarEdgeType> directedGraph =
            new DefaultDirectedGraph<String, GrammarEdgeType>(GrammarEdgeType.class);

		for (Rule r : rules()) {
			for (Definition d : r.getDefinitions()) {
				for (Element e : d.getElements()) {
					if (!e.isNonTerminal())
						continue;
					directedGraph.addVertex(r.getIdDecl().getID());
					directedGraph.addVertex(e.getIdUse().getID());

					GrammarEdgeType et;
					if (r.includes(e.getIdUse().getID()))
						et = GrammarEdgeType.include();
					else
						et = GrammarEdgeType.use();

					directedGraph.addEdge(r.getIdDecl().getID(), e.getIdUse().getID(), et);
				}
			}
		}

		return directedGraph;
	}

	public Set<String> Grammar.computeMetaVarRules(Graph<String, GrammarEdgeType> g) {
		TreeMap<String, String> coveredRules = new TreeMap<String, String>();
		TreeSet<String> candidates = new TreeSet<String>();
		TreeSet<String> pureAlias = new TreeSet<String>();

		for (String n : g.vertexSet()) {
			boolean isUsed = false;
			for (GrammarEdgeType e : g.incomingEdgesOf(n))
				if (e.isUse()) {
					isUsed = true;
					break;
				}
			boolean isAlias = false;
			for (GrammarEdgeType e : g.outgoingEdgesOf(n))
				if (!e.isUse()) {
					isAlias = true;
					break;
				}

			if (!isAlias) {
				candidates.add(n);
				coveredRules.put(n, n);
			}

			if (!isUsed)
				pureAlias.add(n);
		}

		boolean change;
		do {
			change = false;
			for (GrammarEdgeType e : g.edgeSet()) {
				String src = g.getEdgeSource(e);
				String tgt = g.getEdgeTarget(e);
				if (e.isUse())
					continue;
				if (coveredRules.containsKey(tgt)) {
					String oldVal = coveredRules.put(src, coveredRules.get(tgt));
					if (oldVal == null) {
						change = true;
					} else if (!oldVal.equals(coveredRules.get(tgt))) {
						System.out.println("Rule conflict at: " + src + " : "
										   + oldVal + " - " + coveredRules.get(tgt));
					}
				}

				if (coveredRules.containsKey(src) && coveredRules.containsKey(tgt) && pureAlias.contains(tgt)) {
					coveredRules.put(tgt, coveredRules.get(src));
				}
			}
		} while (change);

		for (String r : g.vertexSet()) {
			if (!coveredRules.containsKey(r)) {
				System.out.println("Uncovered rule: " + r);
			} else {
				System.out.println("Covered rule: " + r);
			}
		}

		return coveredRules.keySet();
    }

	public static void Grammar.exportGrammarGraph(Graph<String, GrammarEdgeType> g, String file) {
		DOTExporter<String, GrammarEdgeType> exporter = new DOTExporter<String, GrammarEdgeType>
			(new ComponentNameProvider<String>() {
				 @Override public String getName(String t) { return t; }
			 },
			 null, /* vertexLabelProvider */
			 null, /* edgeLabelProvider */
			 null, /* vertexAttributeProvider */
			 new ComponentAttributeProvider<GrammarEdgeType>() {
				 @Override public Map<String, Attribute> getComponentAttributes(GrammarEdgeType e) {
					 return Collections.singletonMap("color",
													 DefaultAttribute.createAttribute(e.isUse() ? "blue" : "red"));
				 }
			 });
		try {
			Writer writer = new FileWriter(file);
			exporter.exportGraph(g, writer);
		} catch (IOException e) {
			System.err.println(e);
		}
	}

	public java.util.List<String> Grammar.getRulePriority() {
		Graph<String, DefaultEdge> directedGraph =
            new DefaultDirectedGraph<String, DefaultEdge>(DefaultEdge.class);

		for (Rule r : rules()) {
			for (Definition d : r.getDefinitions()) {
				for (Element e : d.getElements()) {
					if (e.isNonTerminal()) {
						directedGraph.addVertex(r.getIdDecl().getID());
						directedGraph.addVertex(e.getIdUse().getID());
						directedGraph.addEdge(r.getIdDecl().getID(),
											  e.getIdUse().getID());
					}
				}
			}
		}


		String entry = null;
		for (String v : directedGraph.vertexSet()) {
			if (directedGraph.inDegreeOf(v) == 0) {
				entry = v;
				break;
			}
		}

		System.out.println("Assumed grammar root: " + entry);

		DepthFirstIterator<String, DefaultEdge> it = new DepthFirstIterator<String, DefaultEdge>(directedGraph, entry);

		java.util.List<String> list = new java.util.ArrayList();
		while (it.hasNext()) {
			list.add(it.next());
		}

		return list;
	}

	private Rule Grammar.buildMetaVarRule(Rule r) {
		Rule metaVarRule = new Rule();
		metaVarRule.setIdUse(r.getIdUse().treeCopyNoTransform());
		metaVarRule.setIdDecl(new IdDecl("META_OR_CONCRETE_" + r.getIdDecl().getID()));

		{
			Definition originalDef = new Definition();
			originalDef.addElement(new Element(new IdUse(r.getIdDecl().getID()), new Opt()));
			metaVarRule.addDefinition(originalDef);
		}

		{
			Definition metaVarDef = new Definition();
			Element el = new Element(new IdUse("METAVARID"), new Opt(new IdUse("id")));
			metaVarDef.addElement(el);
			Precedence prec = new Precedence(new IdUse("PREC_1_" + r.getIdDecl().getID()));
			metaVarDef.addPrecedence(prec);
			String code = String.format("return new MetaVar%s().setVar(new MetaVariable(id));",
										r.getIdUse().getID());
			metaVarDef.setCODE(code);
			metaVarRule.addDefinition(metaVarDef);
		}

		{
			Definition gapDef = new Definition();
			Element el = new Element(new IdUse("GAP"), new Opt());
			gapDef.addElement(el);
			Precedence prec = new Precedence(new IdUse("PREC_2_" + r.getIdDecl().getID()));
			gapDef.addPrecedence(prec);
			String code = String.format("return new Gap%s();",
										r.getIdUse().getID());
			gapDef.setCODE(code);
			metaVarRule.addDefinition(gapDef);
		}

		return metaVarRule;
	}

	private Assoc Grammar.buildPrecedenceStmt(String prec, String name) {
		return new Assoc(prec, new List(new IdUse(name)));
	}

	public void Grammar.replaceHeader(String s) {
		for (Clause c : getClauses()) {
			if (c instanceof Header) {
				Header h = (Header)c;
				h.setCODE(s);
			}
		}
		flushAttrCache();
	}

	public void Grammar.addPatternGrammarClauses(Set<String> rulesToTransform) {
		TreeSet<Rule> metaRules = new TreeSet<Rule>(new Comparator<Rule>() {
				public int compare(Rule r1, Rule r2) {
					return r1.getIdDecl().getID().compareTo(r2.getIdDecl().getID());
				}
			});
		java.util.List<Element> metaElems = new java.util.ArrayList<Element>();
		Set<String> goals = new TreeSet<String>();

		java.util.List<String> rulePriority = getRulePriority();

		for (Rule r : rules()) {
			for (Definition d : r.getDefinitions()) {
				for (Element e : d.getElements()) {
					if (!rulesToTransform.contains(e.getIdUse().getID()))
						continue;
					metaElems.add(e);
				}
			}
			if (rulesToTransform.contains(r.getIdDecl().getID())) {
				metaRules.add(r);
			}
			if (!r.type().equals("ASTNode") && !r.type().equals("ASTList"))
				goals.add(r.getIdDecl().getID());
		}

		// Exclude the following keywords from goals, because they will clash with the
		// Java language
		java.util.List<String> keywords = java.util.Arrays.asList("super", "finally", "throws");
		for (String goalName : goals) {
			if (!keywords.contains(goalName))
				addClause(new Goal(goalName));
		}

		for (Rule r : metaRules) {
			addClause(new Goal("META_OR_CONCRETE_" + r.getIdDecl().getID()));
		}

		for (Element e : metaElems) {
			if (!e.hasName()) {
				// explicitly name the element to the name of
				// the original, if it was unnamed; the code might use this name
				e.setName(new IdUse(e.getIdUse().getID()));
			}
			e.setIdUse(new IdUse("META_OR_CONCRETE_" + e.getIdUse().getID()));
		}

		// Add these rules as goals, to silence the "Rule cannot be reduced error"
		for (Rule r : metaRules) {
			Rule mvr = buildMetaVarRule(r);
			addClause(mvr);
		}

		for (String rule : rulePriority) {
			addClause(buildPrecedenceStmt("nonassoc", "PREC_1_" + rule));
			addClause(buildPrecedenceStmt("nonassoc", "PREC_2_" + rule));
		}


		for (Rule r : rules()) {
			for (Definition d : r.getDefinitions()) {
				for (Element e : d.getElements()) {
					e.flushAttrCache();
				}
				d.flushAttrCache();
			}
			r.flushAttrCache();
		}
		flushAttrCache();
	}

}
